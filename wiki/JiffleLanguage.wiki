#summary jiffle: a JAI ImageFunction scripting language

= Introduction =

The jiffle language is intended to make it easier to create images from expressions whose inputs are image location and/or other image values and which may contain mathematical and logical operators.

<wiki:toc max_depth="2" />

= Description of the language =

Jiffle's preliminary syntax will be familiar to C and Java programmers.  Most arithmetic and logical operators are identical, with the exception of `^` for exponentiation and `^|` for exclusive-or. 

The language is case sensitive. Statements are terminated by a newline or (optionally) a semicolon.

== Arithmetic operators ==
  `^` Raise to power <br>
  `*` Multiply <br>
  `/` Divide <br>
  `%` Modulo (remainder) <br>
  `+` Add <br>
  `-` Subtract <br>

== Logical operators ==
These can be specified using familiar C/Java symbols or capitalized operator names.
  `&&` *AND* <br>
  `||` *OR* <br>
  `^|` *XOR* <br>
  `==` *EQ* <br>
  `!=` *NE* <br>
  `>`  *GT* <br>
  `>=` *GE* <br>
  `<=` *LE* <br>
  `<`  *LT* <br>
  `!`  *NOT* <br>

== Conditional expressions ==
Example:
{{{
   z = (x > 2.5 ? 1 : 0);
}}}

== Function calls ==

Jiffle presently supports functions taking 1 or 2 *double* arguments and returning a *double* value. The language includes a set of basic functions: log(x), sqrt(x), abs(x), rand(x) random double in the range [0,x), randInt(x) random integer (actually a floored double) in the range [0,x), sin(x), cos(x), tan(x), asin(x), acos(x), atan(x), radToDeg(x), degToRad(x).

The next step is to allow users to plug their own functions into the jiffle interpreter and support no-arg and variable arg functions.

== Variables ==

Local variables can be defined to store double values. Variable names must start with a letter, optionally followed by letters, numbers and underscores. Names are case-sensitive.

Boolean variables and lists are not catered for yet.

Jiffle knows a small number of pre-defined constants: PI, E and NaN.

= What's missing ? =

Inputs !  The next step is to add language elements for input images and image coordinates.

Operators for neighbourhood analyses.


= ANTLR grammar for jiffle =
{{{
/*
 * Copyright 2009 Michael Bedward
 * 
 * This file is part of jai-tools.

 * jai-tools is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the 
 * License, or (at your option) any later version.

 * jai-tools is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public 
 * License along with jai-tools.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */

grammar Jiffle;

options {
    output = AST;
    ASTLabelType = CommonTree;
}

tokens {
    ASSIGN;
    CAST;
    EXPR_LIST;
    FUNC_CALL;
    POSTFIX;
    PREFIX;
}

@header {
package jaitools.jiffle.parser;
}

@lexer::header {
package jaitools.jiffle.parser;
}

@members {
    private boolean printParseTree = false;

    public void setPrint(boolean b) { printParseTree = b; }
}


jiffle		: statement+
                ;

statement	: expr EOS
		| EOS
		;

expr		: func_call
                | assign_expr
                | cond_expr
		;

func_call       : ID LPAR expr_list RPAR
                ;

expr_list       : (expr (',' expr)* )?
		;
		
assign_expr     : ID assign_op expr
                ;

cond_expr       : or_expr (QUESTION expr ':' expr)? 
		;
		
or_expr		: xor_expr (OR xor_expr)*
		;

xor_expr	: and_expr (XOR and_expr)*
		;
		
and_expr	: eq_expr (AND eq_expr)*
		;

eq_expr		: comp_expr ((LOGICALEQ | NE) comp_expr)?
		;
		
comp_expr	: add_expr ((GT | GE | LE | LT) add_expr)?
		;

add_expr	: mult_expr ((PLUS | MINUS) mult_expr)*
		;
		
mult_expr	: exp_expr ((TIMES | DIV | MOD) exp_expr)*
		;

exp_expr        : cast_expr (POW cast_expr)*
                ;
		
cast_expr	: LPAR type_name RPAR cast_expr
		| unary_expr
		;	

unary_expr	: incdec_op postfix_expr
		| unary_op postfix_expr
		| postfix_expr
		;
		
postfix_expr	: a=atom_expr (incdec_op)?
		;
		
atom_expr	: ID
		| constant
		| LPAR expr RPAR
		;

constant	: INT_LITERAL
		| FLOAT_LITERAL
		;

incdec_op       : INCR
                | DECR
                ;

unary_op	: PLUS
		| MINUS
		| NOT
		;
		
assign_op	: EQ
		| TIMESEQ
		| DIVEQ
		| MODEQ
		| PLUSEQ
		| MINUSEQ
		;

type_name	: 'int'
		| 'float'
		| 'double'
		| 'boolean'
		;


/* Operators sorted and grouped by precedence order */
INCR            : '++' ;  /* pre-fix and post-fix operations */
DECR            : '--' ;

NOT             : '!' ;

POW             : '^' ;      

TIMES           : '*' ;
DIV             : '/' ;
MOD             : '%' ;

PLUS            : '+' ;
MINUS           : '-' ;

GT		: '>';
GE		: '>=';
LE		: '<=';
LT		: '<';

LOGICALEQ	: '==';
NE		: '!=';

AND		: '&&';

OR		: '||';
XOR		: '^|';

QUESTION        : '?' ;  /* conditional operator ?: */

TIMESEQ         : '*=' ;
DIVEQ           : '/=' ;
MODEQ           : '%=' ;
PLUSEQ          : '+=' ;
MINUSEQ         : '-=' ;
EQ              : '='  ;


/* General symbols and token rules */
LPAR            : '(' ;
RPAR            : ')' ;

ID		: (Letter) (Letter | UNDERSCORE | Digit)*
		;

fragment
Letter		: 'a'..'z' | 'A'..'Z'
		;

UNDERSCORE      : '_' ;

INT_LITERAL	: '0' | NonZeroDigit Digit*
		;

FLOAT_LITERAL	: ('0' | NonZeroDigit Digit*)? '.' Digit* FloatExp?
		;
fragment
Digit           : '0'..'9'
                ;

fragment
NonZeroDigit    : '1'..'9'
                ;

fragment
FloatExp        : ('e'|'E' (PLUS|MINUS)? '0'..'9'+)
                ;
				
EOS		: ';' ;

WS  		:  (' '|'\r'|'\t'|'\u000C'|'\n') ;
}}}