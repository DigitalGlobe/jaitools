#summary jiffle: a JAI ImageFunction scripting language

= Introduction =

The jiffle language is intended to make it easier to create images from expressions 
consisting of mathematical and logical operators, pre-defined and user-defined constants,
and data from input images.

<wiki:toc max_depth="3" />

= Description of the language =

Jiffle's preliminary syntax will be familiar to C and Java programmers.  Most arithmetic and logical operators are identical, with the exception of `^` for exponentiation and `^|` for exclusive-or. 

The language is case sensitive. A statement is terminated by a semicolon and/or a newline (or any combination of the two)...

{{{
// jiffle will even handle this...
a = 3; b = 42

c = a / b ;;
    ;;;

// ...not that we recommend it
}}}

== Operators ==

=== Arithmetic operators ===
  `^` Raise to power <br>
  `*` Multiply <br>
  `/` Divide <br>
  `%` Modulo (remainder) <br>
  `+` Add <br>
  `-` Subtract <br>
  `=` Assignment <br>
  `+=` Additive assignment <br>
  `-=` Subtractive assignment <br>
  `*=` Multiplicative assignment <br>
  `/=` Divisive assignment <br>
  `%=` Modulo assignment <br>

Jiffle supports chained assignments...

{{{

a = b = c = 6 * 7;

}}}

=== Logical operators ===
  `&&` logical AND <br>
  `||` logical OR <br>
  `^|` logical XOR <br>
  `==` equality test <br>
  `!=` inequality test <br>
  `>`  greater than <br>
  `>=` greater than or equal to <br>
  `<=` less than <br>
  `<`  less than or equal to <br>
  `!`  logical complement <br>

=== Conditional expressions ===
Example:
{{{

z = (x > 2.5 ? 1 : 0);

}}}

== Built-in functions ==

=== General functions ===

|| *function* || *description*  || 
||`log(x)`    || natural log    ||
||`sqrt(x)`   || square root    ||
||`abs(x)`    || absolute value ||
||`sin(x)`    || sine of angle (radians) ||
||`cos(x)`    || cosine of angle (radians) ||
||`tan(x)`    || tangent of angle (radians) ||
||`asin(x)`   || inverse sine of angle (radians) ||
||`acos(x)`   || inverse cosine of angle (radians) ||
||`atan(x)`   || inverse tangent of angle (radians) ||
||`radToDeg(x)`|| convert radians to degrees ||
||`degToRad(x)`|| convert degrees to radians ||
||`rand(x)`   || random value in the range [0,x) ||
||`randInt(x)`|| random integer value in range [0,x)||

All of the above functions take a double argument and return a double value (`randInt`
returns a floored double).

=== Image functions ===

|| *function* || *description*  || 
|| x()        || pixel x pos from 0 to image width - 1 ||
|| y()        || pixel y pos from 0 to image height - 1 ||
|| width()    || output image width ||
|| height()   || output image height ||

== Variables ==

Local variables can be defined to store double values. Logical values are stored as 1 (true) or 0 (false).

Variable names are case-sensitive and must start with a letter, optionally followed by letters, numbers and underscores.

Jiffle knows a small number of pre-defined constants: PI, E and NaN. 

The logical constants true and false are also defined and are *not* case sensitive...

{{{
// these are equivalent
lo = true; up = TRUE; silly = TruE;
}}}

== Comments ==

{{{
/* 
 * C-style block comments
 * are supported
 * in jiffle
 */

// As are line comments
}}}

= ANTLR grammar for jiffle =

*Note:* the complete parser grammar with header sections and tree construction elements can be found in the svn repository [http://code.google.com/p/jai-tools/source/browse/#svn/trunk/jiffle/src/main/antlr/jaitools/jiffle/parser here]

*Please treat this grammar as preliminary and assume that it contains errors*

{{{
grammar Jiffle;

prog		: statement+
                ;

statement	: expr eos
		;
		
expr		: assign_expr
                | cond_expr
		;
                
func_call       : ID LPAR expr_list RPAR
                ;

expr_list       : (expr (',' expr)* )?
		;
		
assign_expr     : ID assign_op expr
                ;

cond_expr       : or_expr (QUESTION expr ':' expr)? 
		;
		
or_expr		: xor_expr (OR xor_expr)*
		;

xor_expr	: and_expr (XOR and_expr)*
		;
		
and_expr	: eq_expr (AND eq_expr)*
		;

eq_expr		: comp_expr ((LOGICALEQ | NE) comp_expr)?
		;
		
comp_expr	: add_expr ((GT | GE | LE | LT) add_expr)?
		;

add_expr	: mult_expr ((PLUS | MINUS) mult_expr)*
		;
		
mult_expr	: exp_expr ((TIMES | DIV | MOD) exp_expr)*
		;

exp_expr        : cast_expr (POW cast_expr)*
                ;
		
cast_expr	: LPAR type_name RPAR cast_expr -> (CAST cast_expr)
		| unary_expr
		;	

unary_expr	: incdec_op postfix_expr -> (PREFIX incdec_op postfix_expr)
		| unary_op postfix_expr -> (PREFIX unary_op postfix_expr)
		| postfix_expr
		;
		
postfix_expr	: a=atom_expr (incdec_op)?
		;
		
atom_expr	: ID
		| constant
		| LPAR expr RPAR
                | func_call
		;

constant	: INT_LITERAL
		| FLOAT_LITERAL
		;

incdec_op       : INCR
                | DECR
                ;

unary_op	: PLUS
		| MINUS
		| NOT
		;
		
assign_op	: EQ
		| TIMESEQ
		| DIVEQ
		| MODEQ
		| PLUSEQ
		| MINUSEQ
		;

type_name	: 'int'
		| 'float'
		| 'double'
		| 'boolean'
		;

eos		: (SEMICOLON | NEWLINE)+
		;

BLOCK_COMMENT   : '/*' (~'*' | '*' ~'/')* '*/' { $channel = HIDDEN; }
                ;

LINE_COMMENT    : '//' (~NEWLINE)* NEWLINE { $channel = HIDDEN; }
                ;
                

/* Operators sorted and grouped by precedence order */
INCR            : '++' ;  /* pre-fix and post-fix operations */
DECR            : '--' ;

NOT             : '!' ;

POW             : '^' ;      

TIMES           : '*' ;
DIV             : '/' ;
MOD             : '%' ;

PLUS            : '+' ;
MINUS           : '-' ;

GT		: '>';
GE		: '>=';
LE		: '<=';
LT		: '<';

LOGICALEQ	: '==';
NE		: '!=';

AND		: '&&';

OR		: '||';
XOR		: '^|';

QUESTION        : '?' ;  /* conditional operator ?: */

TIMESEQ         : '*=' ;
DIVEQ           : '/=' ;
MODEQ           : '%=' ;
PLUSEQ          : '+=' ;
MINUSEQ         : '-=' ;
EQ              : '='  ;


/* General symbols and token rules */
LPAR            : '(' ;
RPAR            : ')' ;

ID		: (Letter) (Letter | UNDERSCORE | Digit)*
		;

fragment
Letter		: 'a'..'z' | 'A'..'Z'
		;

/* true and false keywords are defined using case-insensitive fragments
 * (see further down)
 */
TRUE            : T R U E
                ;
                
FALSE           : F A L S E
                ;

UNDERSCORE      : '_' ;

INT_LITERAL	: '0' | NonZeroDigit Digit*
		;

FLOAT_LITERAL	: ('0' | NonZeroDigit Digit*)? '.' Digit* FloatExp?
		;
fragment
Digit           : '0'..'9'
                ;

fragment
NonZeroDigit    : '1'..'9'
                ;

fragment
FloatExp        : ('e'|'E' (PLUS|MINUS)? '0'..'9'+)
                ;
				
SEMICOLON	: ';' ;

/* Mac: \r  PC: \r\n  Unix \n */
NEWLINE		: '\r' '\n'?
		| '\n'
		;

/* Fragment tokens for selective case-insensitive matching */
fragment A:('a'|'A');
fragment B:('b'|'B');
fragment C:('c'|'C');
fragment D:('d'|'D');
fragment E:('e'|'E');
fragment F:('f'|'F');
fragment G:('g'|'G');
fragment H:('h'|'H');
fragment I:('i'|'I');
fragment J:('j'|'J');
fragment K:('k'|'K');
fragment L:('l'|'L');
fragment M:('m'|'M');
fragment N:('n'|'N');
fragment O:('o'|'O');
fragment P:('p'|'P');
fragment Q:('q'|'Q');
fragment R:('r'|'R');
fragment S:('s'|'S');
fragment T:('t'|'T');
fragment U:('u'|'U');
fragment V:('v'|'V');
fragment W:('w'|'W');
fragment X:('x'|'X');
fragment Y:('y'|'Y');
fragment Z:('z'|'Z');

WS  		:  (' '|'\t'|'\u000C') ;

}}}