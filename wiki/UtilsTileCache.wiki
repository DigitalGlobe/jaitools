#summary a JAI TileCache implementation to handle large volumes of image data
#labels Featured

=!DiskMemTileCache=

*module:* utils<br>
*package:* jaitools.tilecache

==Description==

JAI operations can use a cache class to store image tiles. The default Sun reference implementation of `TileCache` stores all tiles in memory. The !DiskMemTileCache class uses both disk and memory storage to allow operations to work with large volumes of image data without being constrained by available memory.

Each image tile added to the cache is placed into memory. If the cache does not have enough free memory to store a tile, it makes space available by removing one or more currently resident tiles of the lowest priority. By default, tile priorites are based on access time (most recent being highest). Users can work with other priority schemes by providing a class that implements `Comparator<CachedTile>`.

When a tile is swapped out of memory to make space for other tiles its data are written to disk. If the tile is accessed later it will be copied back into memory.

==Examples of use==

Here, an instance of !DiskMemTileCache is created and set as the default tile cache for JAI operations...
{{{
TileCache cache = new DiskMemTileCache();
JAI.getDefaultInstance().setTileCache(cache);
}}}

Alternatively, the cache can be passed to individual JAI operations as a rendering hint along
with other tile settings as in this example...
{{{
Map<RenderingHints.Key, Object> imgParams = new HashMap<RenderingHints.Key, Object>();
TileCache cache = new DiskMemTileCache();
imgParams.put(JAI.KEY_TILE_CACHE, cache);

ImageLayout layout = new ImageLayout();
layout.setTileWidth(128);
layout.setTileHeight(128);
imgParams.put(JAI.KEY_IMAGE_LAYOUT, layout);

RenderingHints hints = new RenderingHints(imgParams);

// later...
RenderedOp op = JAI.create(opname, paramBlock, hints);
}}}

The cache's memory capacity and handling of new tiles can be set when constructing an instance of !DiskMemTileCache...
{{{
Map<String, Object> cacheParams = new HashMap<String, Object>();
cacheParams.put(DiskMemTileCache.KEY_INITIAL_MEMORY_CAPACITY, 1L * 1024 * 1024);
cacheParams.put(DiskMemTileCache.KEY_ALWAYS_DISK_CACHE, Boolean.TRUE);

DiskMemTileCache cache = new DiskMemTileCache(cacheParams);
}}}

When the cache is being used for image tiles that are inexpensive to re-create (e.g. data read from disk rather as opposed to data generated by a time-consuming algorithm) it may be convenient to remove the cache's memory-resident tiles periodically so that the cache doesn't hog memory more urgently required by other parts of an application...
{{{
cache.flushMemory();
}}}

Memory flushing can be automated like this...
{{{
// auto-flush cache memory every 5 seconds
cache.setAutoFlushMemoryInterval( 5000 );
cache.setAutoFlushMemoryEnabled( true );
}}}

Periodic memory flushing can also be specified when creating a new cache...
{{{
// request that the new cache perform auto-flushing of memory and
// that it always cache newly added tiles to disk
Map<String, Object> cacheParams = new HashMap<String, Object>();
cacheParams.put(DiskMemTileCache.KEY_AUTO_FLUSH_MEMORY_ENABLED, Boolean.TRUE);
cacheParams.put(DiskMemTileCache.KEY_AUTO_FLUSH_MEMORY_INTERVAL, 5000); 
cacheParams.put(DiskMemTileCache.KEY_ALWAYS_DISK_CACHE, Boolean.TRUE);
DiskMemTileCache cache = new DiskMemTileCache(cacheParams);
}}}

Cache use can be monitored by classes that implement the `java.util.Observer` interface. See `jaitools.demo.tilecache.TileCacheDemo` for an example.

==See also==

[DiskMemImage] - a writable tiled image class that uses !DiskMemTileCache