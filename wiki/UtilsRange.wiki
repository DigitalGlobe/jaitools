#summary implements numeric intervals and comparisons

=Range=

*package:* jaitools.utils

==Description==

Yet another numeric Range class. It is used with the RangeLookup operator but is also available for general use.

Range is a generic class that can be used with types that extend Number and implement Comparable. A Range is defined by its endpoints. If the min (lower bound) end-point is the same as the max (upper-bound) end-point then the Range represents a point, also referred to as a degenerate interval.

An end-point can be positioned at a finite value, in which case it is said to be _closed_, or at positive or negative infinity, in which case it is said to be _open_. For finite end-points, a Range can include or exclude the end-point. Included end-points correspond to `[` and `]` in interval notation, while excluded end-points correspond to `(` and `)`.

==Comparisons==

Comparisons between a pair of Range objects are handled by the !RangeComparator class. Hayes (2003) describes 18 possible pair-wise comparisons between intervals (see his Fig. 3). The !RangeComparator.Result enum has a constant for each of these possible relationships...

||*Name*||*Notation*||*Description*||
||LLLL||<<<<||completely less than||
||LLLE||<<<=||extends to min of||
||LLLG||<<<>||starts below and extends within||
||LLEG||<<=>||starts below and extends to max of||
||LEGG||<=>>||starts with and extends beyond||
||LLEE||<<==||starts below and has max at point location of||
||EEGG||==>>||extends from point location of||
||LEEG||<==>||is exactly equal to finite interval||
||EEEE||====||is exactly equal to point||
||LLGG||<<>>||strictly encloses||
||LGLG||<><>||is strictly enclosed by||
||LGGG||<>>>||starts within and extends beyond||
||LGEG||<>=>||starts within and extends to max of||
||LELG||<=<>||starts with and ends within||
||EGEG||=>=>||is a point at max of||
||LELE||<=<=||is a point at min of||
||EGGG||=>>>||extends from max of||
||GGGG||>>>>||is completely greater than||


==Examples of use==
{{{
// Create a range representing the interval [5, 10)
// ie. 5 is included in the range, 10 is excluded
Range<Integer> r1 = new Range<Integer>(5, true, 10, false);

// Create a range representing the interval (&infin;, 10]
// this time using the static create function
Range<Integer> r2 = Range.create(null, false, 10, true);

// Get the relationship between these two intervals from the
// 'point of view' of r1
RangeComparator.Result comp = r1.compareTo(r2);
System.out.println(String.format("r1 %s r2", comp.getDesc()));

// A point (degenerate) interval
Range<Integer> r3 = Range.create(10);
comp = r3.compareTo(r2);
System.out.println(String.format("r3 %s r2", comp.getDesc()));

}}}

The output from the above code is...
{{{
r1 is strictly enclosed by r2
r3 is a point at max of r2
}}}

As well as these fine-grain comparisons the Range class also provides higher-level comparison methods *contains* and *intersects* as illustrated in this example...

{{{
// the interval [-5.0, 5.0)
Range<Float> r1 = Range.create(-5.0f, true, 5.0f, false);

float[] testValues = {-5.0f, 0f, 5.0f};

for (float val : testValues) {
    String s;
    if (r1.contains(val)) {
        s = String.format("%.1f is within r1", val);
    } else {
        s = String.format("%.1f is outside r1", val);
    }
    System.out.println(s);
}

// test for intersection of r1 and the intervals 
// [0.0, &infin;) and [5.0, &infin;)
float[] lowerBounds = {0f, 5.0f};
for (float lower : lowerBounds) {
    String s = String.format("r1 %s with [%.1f, inf)",
        (r1.intersects(Range.create(lower, true, null, false)) ? 
            "intersects" : "does not intersect"),
        lower);

    System.out.println(s);
}

}}}

The output is...

{{{
-5.0 is within r1
0.0 is within r1
5.0 is outside r1
r1 intersects with [0.0, inf)
r1 does not intersect with [5.0, inf)
}}}

==Reference==
Brian Hayes (2003) A lucid interval. _American Scientist_ *91*(6):484-488.

Available at: http://www.cs.utep.edu/interval-comp/hayes.pdf