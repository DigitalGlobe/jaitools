#summary a helper class to create KernelJAI objects

=!KernelFactory=

==Description==

!KernelFactory is a class with static methods to make it easier to create KernelJAI objects with the non-zero kernel elements arranged as one of:
 * circle
 * annulus
 * rectangle

Kernels representing more complex shapes can also be created from java.awt.Shape objects.

==Examples of use==

Here we create a kernel representing a raster circle with a radius of 3 pixels, as set by the first argument. The second argument specifies that elements within the circle will have a value of 1.0 (within the circle) or 0.0 (outside the circle). The third argument sets the value of the centre (key) kernel element.

{{{
KernelJAI circle = KernelFactory.createCircle(3, Kernel.ValueType.BINARY, 1.0);

// Let's have a look at it...
System.out.println(KernelUtil.kernelToString(circle, true);
}}}

Which produces this...

{{{
[[0001000]
 [0111110]
 [0111110]
 [1111111]
 [0111110]
 [0111110]
 [0001000]]
}}}

Next, an example of creating a kernel for distance-weighted operations...

Once again we create a circular kernel, this time with a radius of 3 pixels. The value of each element in the kernel will be the inverse of the distance to the kernel centre. We set the centre element's value is set to 1.0

{{{
KernelJAI distWt = KernelFactory.createCircle(3, Kernel.ValueType.INVERSE_DISTANCE, 1.0);
System.out.println(KernelUtil.kernelToString(distWt, true);
}}}

And this is the output...

{{{
[[0.0000 0.0000 0.0000 0.3333 0.0000 0.0000 0.0000]
 [0.0000 0.3536 0.4472 0.5000 0.4472 0.3536 0.0000]
 [0.0000 0.4472 0.7071 1.0000 0.7071 0.4472 0.0000]
 [0.3333 0.5000 1.0000 1.0000 1.0000 0.5000 0.3333]
 [0.0000 0.4472 0.7071 1.0000 0.7071 0.4472 0.0000]
 [0.0000 0.3536 0.4472 0.5000 0.4472 0.3536 0.0000]
 [0.0000 0.0000 0.0000 0.3333 0.0000 0.0000 0.0000]]
}}}

You can also make an annulus (doughnut) kernel. In this example we create a kernel with an outer radius of 3 pixels, and an inner radius (the hole in the doughnut) of 2 pixels.

{{{
KernelJAI annulus = KernelFactory.createAnnulus(3, 2, Kernel.ValueType.BINARY, 0.0);
System.out.println(KernelUtil.kernelToString(annulus, true);
}}}

Which prints this output...

{{{
[[0001000]
 [0110110]
 [0100010]
 [1000001]
 [0100010]
 [0110110]
 [0001000]]
}}}

You can create a kernel from any closed, polygonal object that implements java.awt.Shape. In this example we create a narrow elliptical kernel, with the long axis of the ellipse having an upper-left to lower-right (NW - SE) orientation. Such a kernel might be part of a landscape fire model...

{{{
// create an ellipse with a horizontal long axis
Shape ell = new Ellipse2D.Float(0, 0, 10, 5);

// create an AffineTransform to rotate the ellipse 45 degrees clock-wise
AffineTransform at = AffineTransform.getRotateInstance(Math.PI/4);

// create the kernel with its key element at the upper-left corner (0,0)
KernelJAI ellKern = KernelFactory.createFromShape(
    ell, at, KernelFactory.ValueType.BINARY, 0, 0, 0f);

// now print it to convince ourselves that we have what we want
System.out.println(KernelUtil.kernelToString(ellKern, true));
}}}

And here is the thing of beauty that results...

{{{
[[0000000000]
 [0011100000]
 [0111111000]
 [0111111100]
 [0011111100]
 [0001111110]
 [0001111110]
 [0000011110]
 [0000001110]
 [0000000000]]
}}}

Note that the kernel's key element, which we set as the upper-left corner, is disjoint from the elements within the ellipse. This is perfectly valid (and hopefully what we wanted).